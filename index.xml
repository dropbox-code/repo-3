<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Portable Data-Parallel Python Extensions with oneAPI</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/</link><description>Recent content on Portable Data-Parallel Python Extensions with oneAPI</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 02 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/index.xml" rel="self" type="application/rss+xml"/><item><title>About oneAPI</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/oneapi/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/oneapi/</guid><description>The Unified Acceleration Foundation (UXL) under the umbrella of Linux Foundation is driving an open standard accelerator software ecosystem that includes compilers and performance libraries. This software ecosystem standardizes programming of different types of accelerators, such as multi-core CPUs, GPUs, some FPGAs, etc. from different vendors.
Intel&amp;rsquo;s oneAPI DPC++ compiler is an implementation of the SYCL-2020 standard that is a part of UXL foundation&amp;rsquo;s overall language design standardization for accelerator programming in C++.</description></item><item><title>First DPC++ app</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/first-app/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/first-app/</guid><description>For an in-depth introduction to SYCL and to accelerators programming please refer to the &amp;ldquo;Data Parallel C++&amp;rdquo; open access e-book.
A SYCL application runs on SYCL platform (host, connected to one or more heterogeneous devices). The application is structured in three scopes: application scope, command group scope, and kernel scope. The kernel scope specifies a single kernel function that will be compiled by the device compiler and executed on the device.</description></item><item><title>KDE DPC++ example</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/kde-cpp/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/kde-cpp/</guid><description>Given a sample of \(n\) observations \(x_i\) drawn from an unknown underlying continuous distribution \(f(x)\), the kernel density estimate of that density function is computed as follows, for some kernel smoothing parameter \(h \in \mathbb{R}\):
$$ \hat{f}(x) = \frac{1}{n} \sum_{i=1}^{n} \frac{1}{h} K\left(\frac{x - x_i}{h}\right) $$
An example of NumPy code performing the estimation, for a common choice of kernel function as standard \(d\)-dimensional Gaussian distribution:
def kde(poi : np.ndarray, sample : np.</description></item><item><title>KDE Python extension</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/kde-python/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/kde-python/</guid><description>Since SYCL builds on C++, we are going to use the pybind11 project to generate a Python extension. We also need Python objects to carry USM allocations of input and output data, such as dpctl (Data Parallel Control Python package). The dpctl package also provides Python objects corresponding to DPC++ runtime objects:
Python object SYCL C++ object dpctl.SyclQueue sycl::queue dpctl.SyclDevice sycl::device dpctl.SyclContext sycl::context dpctl.SyclEvent sycl::event dpctl provides integration with pybind11 supporting castings between dpctl Python objects and corresponding C++ SYCL classes listed in the table above.</description></item><item><title>oneMKL Python extension</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/onemkl/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/docs/onemkl/</guid><description>Given a matrix \(A\), the QR decomposition of \(A\) is defined as the decomposition of \(A\) into the product of matrices \(Q\) and \(R\) such that \(Q\) is orthonormal and \(R\) is upper-triangular.
QR factorization is a common routine in more optimized LAPACK libraries, so rather than write and implement an algorithm ourselves, it would be preferable to find a suitable library routine.
Since dpctl.tensor.usm_ndarray is a Python object with an underlying USM allocation, it is possible to write extensions which wrap oneAPI Math Kernel Library Interfaces (oneMKL Interfaces) USM routines and then call them on the dpctl.</description></item><item><title>Search Results</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-scipy-2024/search/</guid><description/></item></channel></rss>